<!DOCTYPE html>
<html>
<head>
    <title>SugarPP</title>
</head>
<body>

    <h1 id="sugarpp">SugarPP</h1>
<p>A collection of my syntactic 🍬 when programming in C++. <strong>When can we have nice things?</strong></p>
<ul>
<li><a href="#sugarpp">SugarPP</a>
<ul>
<li><a href="#kotlin-when-c-port">Kotlin <code>when</code> C++ port</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#requirement">Requirement</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#advanced-usage">Advanced Usage</a></li>
<li><a href="#to-do">To-DO</a></li>
</ul>
</li>
<li><a href="#io">IO</a>
<ul>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#usage-1">Usage</a></li>
<li><a href="#example-1">Example</a></li>
</ul>
</li>
<li><a href="#range">Range</a>
<ul>
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#example-2">Example</a></li>
<li><a href="#usage-2">Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="kotlin-when-c-port">Kotlin <code>when</code> C++ port</h2>
<p>A header only port of <code>when</code> statement/expression in kotlin.</p>
<h3 id="introduction">Introduction</h3>
<p>In <a href="https://kotlinlang.org/docs/reference/basic-syntaxhtml#using-when-expression">the official kotlin language tutorial</a>, the <code>when</code> expression is a pretty nice syntax sugar forreplacing traditional <code>switch case</code> statement seens in most languages. The drawback for<code>switch</code> at least in C/C++ though is that it only supports matching <strong>integer</strong> values. Butthe kotlin's <code>when</code> basically supports these operations:</p>
<ul>
<li>value matching (for all comparable type)</li>
</ul>
<pre><code class="language-kotlin">when (x) {
    1 -&gt; print(&quot;x == 1&quot;)
    2 -&gt; print(&quot;x == 2&quot;)
    else -&gt; { // Note the block
        print(&quot;x is neither 1 nor 2&quot;)
    }
}
</code></pre>
<ul>
<li>type matching</li>
</ul>
<pre><code class="language-kotlin">fun describe(obj: Any): String =
    when (obj) {
        1          -&gt; &quot;One&quot;
        &quot;Hello&quot;    -&gt; &quot;Greeting&quot;
        is Long    -&gt; &quot;Long&quot;
        !is String -&gt; &quot;Not a string&quot;
        else       -&gt; &quot;Unknown&quot;
    }
</code></pre>
<ul>
<li>range matching</li>
</ul>
<pre><code class="language-kotlin">when (x) {
    in 1..10 -&gt; print(&quot;x is in the range&quot;)
    in validNumbers -&gt; print(&quot;x is valid&quot;)
    !in 10..20 -&gt; print(&quot;x is outside the range&quot;)
    else -&gt; print(&quot;none of the above&quot;)
}
</code></pre>
<p>This project tries to mock kotlin's <code>when</code> in C++. It may sounds stupid, but it shows howpowerful <code>template</code> can be, yet I only used a small portition of its power.</p>
<h3 id="usage">Usage</h3>
<p>Just include the <code>When/When.hpp</code> header in your project.</p>
<h3 id="requirement">Requirement</h3>
<p>Any compiler that supports C<ins>17, because if would be so hard to do without <code>constexpr if</code>(*I may consider adding support for pre C</ins>17 if I am more advanced*)
I also implemented the same functionality using C++20 concepts because it's cool :)</p>
<h3 id="example">Example</h3>
<p>Example is included in <code>main.cpp</code>. Here I copied them without the comments for a briefintuition.</p>
<pre><code class="language-cpp">#include &quot;When.hpp&quot;
#include &quot;../IO/IO.hpp&quot; //for print()
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
using namespace std::literals;
int main()
{
    int x = 1;
    when((x),
        1,          std::function{ [] {puts(&quot;x==1&quot;); } },
        2,          std::function{ [] {puts(&quot;x==2&quot;); } },
        Else(),     std::function{ [] {puts(&quot;x is neither 1 nor 2&quot;); } }
    )();//&quot;x==1&quot;
    int temperature = 10;
    print(when((temperature),
              Range(INT_MIN, 0),    &quot;freezing&quot;,
              Range(1, 15),         &quot;cold&quot;,
              Range(16, 20),        &quot;cool&quot;,
              Range(21, 25),        &quot;warm&quot;,
              Range(26, INT_MAX),   &quot;hot&quot;,
              Else(),               &quot;WTF?&quot;
    )); //&quot;cold&quot;

    auto describe = [](auto &amp;&amp;obj) {
        return when((obj),
                    1,                      &quot;One&quot;s,
                    &quot;hello&quot;s,               &quot;Greeting&quot;s,
                    is&lt;long&gt;(),             &quot;long&quot;s,
                    is_not&lt;std::string&gt;(),  &quot;Not a string&quot;s,
                    Else(),                 &quot;Unknown string&quot;s);
    };
    print(describe(1));                   //&quot;One&quot;
    print(describe(&quot;hello&quot;s));            //&quot;Greeting&quot;
    print(describe(1000l));               //&quot;long&quot;
    print(describe(2));                   //&quot;Not a string&quot;
    print(describe(&quot;random string&quot;s));    //&quot;Unknown string&quot;
    /*C string is also supported*/
    auto describe2 = [](auto&amp;&amp; obj) {
        return when((obj),
            1,                              &quot;One&quot;,
            &quot;hello&quot;,                        &quot;Greeting&quot;,
            is&lt;long&gt;(),                     &quot;long&quot;,
            is_not&lt;const char*&gt;(),          &quot;Not a string&quot;,
            Else(),                         &quot;Unknown string&quot;);
    };
    print(describe2(1));                 //&quot;One&quot;
    print(describe2(&quot;hello&quot;));           //&quot;Greeting&quot;
    print(describe2(1000l));             //&quot;long&quot;
    print(describe2(2));                 //&quot;Not a string&quot;
    print(describe2(&quot;random string&quot;));   //&quot;Unknown string&quot;
}
</code></pre>
<h3 id="advanced-usage">Advanced Usage</h3>
<p>Now it supports grouped logical expression in matching branches, like <code>AND, OR, NOT</code>.
You can find the implementation in <code>GroupedCondition.hpp</code>.
An example (also included in <code>main.cpp</code>):</p>
<pre><code class="language-cpp">    auto describe = [](auto &amp;&amp;obj) {
        return when((obj),    
                    OR(1,2),                  &quot;One or two&quot;s,
                    &quot;hello&quot;s,                   &quot;Greeting&quot;s,
                    is&lt;long&gt;(),                 &quot;long&quot;s,
                    NOT(is&lt;std::string&gt;()),    &quot;Not a string&quot;s,
                    Else(),                     &quot;Unknown string&quot;s);
    };
    print(describe(1));                   //&quot;One or two&quot;
    print(describe(&quot;hello&quot;s));            //&quot;Greeting&quot;
    print(describe(1000l));               //&quot;long&quot;
    print(describe(2));                   //&quot;Not a string&quot;
    print(describe(&quot;random string&quot;s));    //&quot;Unknown string&quot;
</code></pre>
<h3 id="to-do">To-DO</h3>
<ul>
<li><del>Support for direct contrary operation (for example, <code>!is&lt;long&gt;</code> instead of<code>is_not&lt;long&gt;</code>).</del> √</li>
<li>Better lambda support in matching branches</li>
</ul>
<h2 id="io">IO</h2>
<p>A convenient helper function for substitute <code>std::cin</code> that just <strong>works as you intended.</strong> No more <code>getchar()</code> for <em>eating</em> the enter key nonsense! Let <code>print() / printLn()</code> helps to eliminate ugly <code>::</code> and <code>&lt;&lt;</code></p>
<h3 id="introduction-1">Introduction</h3>
<p>The <code>input</code> template function is similar to <code>python</code>. It prints a <code>prompt</code> message and does the following things with error handling, which means clearing any bad bit and ignores the rest of the input and can be specify to <code>retry</code> until the user entered the right thing. (<strong>default is retry enabled</strong>)</p>
<ul>
<li>If the type is a primitive, it works the same as <code>std::cin &gt;&gt;</code>
<ul>
<li>If the type is <code>unsigned</code> number type, and it receives a negative number, it converts to the absolute value</li>
</ul>
</li>
<li>If the type is <code>std::string</code>, it works the same as <code>std::getline</code></li>
</ul>
<p>The <code>print()</code> function template prints <strong>ANY</strong> number of arguments, separated by a template argument <code>delim</code> (default to a space).</p>
<p>The <code>printLn()</code> function template prints <strong>ANY</strong> number of arguments, one line at a time.</p>
<h3 id="usage-1">Usage</h3>
<p>Just include <code>./IO/IO.hpp</code>.</p>
<h3 id="example-1">Example</h3>
<p>A more detailed example is in <code>./IO/main.cpp</code></p>
<pre><code class="language-cpp">#include &quot;IO.hpp&quot;
int main()
{
    auto date = input&lt;int&gt;(&quot;Today's data: &quot;);
    auto day = input&lt;std::string&gt;(&quot;What day is today? &quot;);
    auto someChar = input&lt;char&gt;(&quot;Enter a character: &quot;, false);  //retry disabled

    print(&quot;Today is&quot;, date, &quot;, &quot;, day);
}
</code></pre>
<h2 id="range">Range</h2>
<p>Simplify your <code>for</code> loop and everything you want from a numerical range.
<em>Not to be confused with C++20 ranges!</em></p>
<h3 id="introduction-2">Introduction</h3>
<p>In tons of other programming languages, there are the similar syntax as follows:</p>
<pre><code>for(var i in [0..10])
{...}

for i, v in enumerate(someArray):
    # python syntax
</code></pre>
<p>My <code>Range</code> class template suppors:</p>
<ul>
<li>With sepecified <code>start</code>, <code>end</code> and <code>step (default = 1)</code>, which can be used in C++ range-based for loop. Type will be inferred (with C++17), and if there is discrepancy, will be converted to the right type</li>
<li>Generate random number in the range</li>
<li>Fill a container with random number</li>
</ul>
<p>My <code>Enumerate</code> class template is also used in range-based for loop. And returns a <code>std::pair</code> of <code>index</code> and an <code>iterator</code> from an <code>iterable</code> of the constructed <code>Enumerate</code> class. And it's better to be used together with structured-binding (C++17), eg: <code>for(auto [i, v] : Enumerate(someArray))</code></p>
<h3 id="example-2">Example</h3>
<pre><code class="language-cpp">#include &quot;../IO/IO.hpp&quot; //for print()
#include &quot;Range.hpp&quot;
#include &quot;Enumerate.hpp&quot;
int main()
{
    /*use Range in range-based for loop*/
    for (auto i : Range(0, 10))
        print(i);

    /*use range for a random number*/
    Range r(-1, 100000);
    print(&quot;Random number in &quot;, r, &quot; is &quot;, r.rand());

    /*use range to fill a C style array*/
    double arr[10];
    Range(-500.0, 500.0).fillRand(arr);

    /*use range to fill a STL container*/
    std::array&lt;char, 20&gt; arr2;
    Range('A', 'z').fillRand(arr2);

    /*Alternatively .randFast() provides a faster way for generating random number using rand() in C*/
    int arr3[10];
    Range(-200, 300).fillRandFast(arr3);

    std::array arr{ &quot;cpp&quot;, &quot;sugar&quot;, &quot;sweet&quot; };
    for(auto [index, string]:Enumerate(arr))
        print&lt;'\t'&gt;(index, string);
    /*
        0       cpp
        1       sugar
        2       sweet
    */

    print(&quot;1D range&quot;);
    for (auto i : Range(2.0, 10.0, 3))
        print(i);
    
    /*
        1D range
        2
        5
        8
    */
    print(&quot;2D range&quot;);
    for (auto [i, j] : Range(-5, 1) | Range(0, 3))
        print(i, '\t', j);

    /*
        2D range
        -5       0
        -5       1
        -5       2
        -4       0
        -4       1
        -4       2
        -3       0
        -3       1
        -3       2
        -2       0
        -2       1
        -2       2
        -1       0
        -1       1
        -1       2
        0        0
        0        1
        0        2
    */
}
</code></pre>
<h3 id="usage-2">Usage</h3>
<p>Just include <code>./Range/Range.hpp</code> for <code>Range</code> and <code>./Enumerate/Enumerate.hpp</code> for <code>Enumerate</code></p>


</body>
</html>